{
    "sourceFile": "src/features/visualizer/hooks/useGitGraph.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1762155836890,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762254149734,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,10 +9,20 @@\n // When an `instanceId` is provided, the same id returns the same GitGraph\r\n // across re-renders of that component tree; different ids are isolated.\r\n const graphInstances = new Map();\r\n \r\n-export const useGitGraph = (instanceId) => {\r\n+// Overload: useGitGraph(opts?) where opts can be:\r\n+// - string (instanceId)\r\n+// - { instanceId?: string, graph?: GitGraph }\r\n+export const useGitGraph = (opts) => {\r\n+  const instanceId = typeof opts === \"string\" ? opts : opts?.instanceId;\r\n+  const externalGraph = typeof opts === \"object\" ? opts?.graph : undefined;\r\n+\r\n   const [gitGraph] = useState(() => {\r\n+    // Explicit external graph always wins and guarantees isolation\r\n+    if (externalGraph instanceof GitGraph) {\r\n+      return externalGraph;\r\n+    }\r\n     if (instanceId) {\r\n       if (!graphInstances.has(instanceId)) {\r\n         graphInstances.set(instanceId, new GitGraph());\r\n       }\r\n"
                }
            ],
            "date": 1762155836890,
            "name": "Commit-0",
            "content": "import { useState, useCallback, useMemo } from \"react\";\r\nimport { GitGraph } from \"../core/gitGraph\";\r\nimport { convertToReactFlow, getAllBranches } from \"../utils/graphLayout\";\r\n\r\n/**\r\n * Custom hook to manage Git graph state and operations\r\n */\r\n// Optional instance registry to allow multiple isolated graphs on the same page\r\n// When an `instanceId` is provided, the same id returns the same GitGraph\r\n// across re-renders of that component tree; different ids are isolated.\r\nconst graphInstances = new Map();\r\n\r\nexport const useGitGraph = (instanceId) => {\r\n  const [gitGraph] = useState(() => {\r\n    if (instanceId) {\r\n      if (!graphInstances.has(instanceId)) {\r\n        graphInstances.set(instanceId, new GitGraph());\r\n      }\r\n      return graphInstances.get(instanceId);\r\n    }\r\n    // No id provided â†’ create a dedicated instance for this hook call\r\n    return new GitGraph();\r\n  });\r\n  const [updateCounter, setUpdateCounter] = useState(0);\r\n\r\n  // Force re-render by incrementing counter\r\n  const forceUpdate = useCallback(() => {\r\n    setUpdateCounter((prev) => prev + 1);\r\n  }, []);\r\n\r\n  // Commit operation\r\n  const commit = useCallback(\r\n    (message) => {\r\n      try {\r\n        gitGraph.commit(message);\r\n        forceUpdate();\r\n        return { success: true };\r\n      } catch (error) {\r\n        return { success: false, error: error.message };\r\n      }\r\n    },\r\n    [gitGraph, forceUpdate]\r\n  );\r\n\r\n  // Create branch operation\r\n  const createBranch = useCallback(\r\n    (branchName) => {\r\n      try {\r\n        gitGraph.createBranch(branchName);\r\n        forceUpdate();\r\n        return { success: true };\r\n      } catch (error) {\r\n        return { success: false, error: error.message };\r\n      }\r\n    },\r\n    [gitGraph, forceUpdate]\r\n  );\r\n\r\n  // Checkout operation\r\n  const checkout = useCallback(\r\n    (branchName) => {\r\n      try {\r\n        gitGraph.checkout(branchName);\r\n        forceUpdate();\r\n        return { success: true };\r\n      } catch (error) {\r\n        return { success: false, error: error.message };\r\n      }\r\n    },\r\n    [gitGraph, forceUpdate]\r\n  );\r\n\r\n  // Merge operation\r\n  const merge = useCallback(\r\n    (sourceBranch) => {\r\n      try {\r\n        gitGraph.merge(sourceBranch);\r\n        forceUpdate();\r\n        return { success: true };\r\n      } catch (error) {\r\n        return { success: false, error: error.message };\r\n      }\r\n    },\r\n    [gitGraph, forceUpdate]\r\n  );\r\n\r\n  // Reset operation - moves current branch pointer to specified commit\r\n  const reset = useCallback(\r\n    (commitId) => {\r\n      try {\r\n        gitGraph.reset(commitId);\r\n        forceUpdate();\r\n        return { success: true };\r\n      } catch (error) {\r\n        return { success: false, error: error.message };\r\n      }\r\n    },\r\n    [gitGraph, forceUpdate]\r\n  );\r\n\r\n  // Revert operation\r\n  const revert = useCallback(\r\n    (commitId) => {\r\n      try {\r\n        if (!commitId) {\r\n          throw new Error(\"No commit selected\");\r\n        }\r\n        gitGraph.revert(commitId);\r\n        forceUpdate();\r\n        return { success: true };\r\n      } catch (error) {\r\n        return { success: false, error: error.message };\r\n      }\r\n    },\r\n    [gitGraph, forceUpdate]\r\n  );\r\n\r\n  // Rebase operation\r\n  const rebase = useCallback(\r\n    (sourceBranch, targetBranch) => {\r\n      try {\r\n        if (!sourceBranch || !targetBranch) {\r\n          throw new Error(\"Both source and target branches are required\");\r\n        }\r\n        gitGraph.rebase(sourceBranch, targetBranch);\r\n        forceUpdate();\r\n        return { success: true };\r\n      } catch (error) {\r\n        return { success: false, error: error.message };\r\n      }\r\n    },\r\n    [gitGraph, forceUpdate]\r\n  );\r\n\r\n  // Clear entire graph to initial state\r\n  const clearGraph = useCallback(() => {\r\n    try {\r\n      gitGraph.clear();\r\n      forceUpdate();\r\n      return { success: true };\r\n    } catch (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n  }, [gitGraph, forceUpdate]);\r\n\r\n  // Convert graph to React Flow format (memoized)\r\n  const { nodes, edges } = useMemo(() => {\r\n    return convertToReactFlow(gitGraph);\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [updateCounter]);\r\n\r\n  // Get all branches\r\n  const branches = useMemo(() => {\r\n    return getAllBranches(gitGraph.branches);\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [updateCounter]);\r\n\r\n  // Get current HEAD\r\n  const currentBranch = gitGraph.HEAD;\r\n\r\n  // Get commit by ID\r\n  const getCommit = useCallback(\r\n    (commitId) => {\r\n      return gitGraph.commits.get(commitId);\r\n    },\r\n    [gitGraph]\r\n  );\r\n\r\n  // Get branches for a commit\r\n  const getBranchesForCommit = useCallback(\r\n    (commitId) => {\r\n      const result = [];\r\n      for (const [branchName, branchCommitId] of gitGraph.branches) {\r\n        if (branchCommitId === commitId) {\r\n          result.push(branchName);\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n    [gitGraph]\r\n  );\r\n\r\n  // Get stats\r\n  const stats = useMemo(() => {\r\n    return {\r\n      commits: gitGraph.commits.size,\r\n      branches: gitGraph.branches.size,\r\n    };\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [updateCounter]);\r\n\r\n  return {\r\n    // Operations\r\n    commit,\r\n    createBranch,\r\n    checkout,\r\n    merge,\r\n    reset,\r\n    revert,\r\n    rebase,\r\n\r\n    // Data\r\n    nodes,\r\n    edges,\r\n    branches,\r\n    currentBranch,\r\n    stats,\r\n\r\n    // Helpers\r\n    getCommit,\r\n    getBranchesForCommit,\r\n    gitGraph, // Expose gitGraph instance for advanced operations\r\n    forceUpdate, // Expose forceUpdate for external operations\r\n    clearGraph, // Expose clearGraph to reset to initial state\r\n  };\r\n};\r\n"
        }
    ]
}