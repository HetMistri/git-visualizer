{
    "sourceFile": "src/features/visualizer/utils/graphLayout.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1762148705486,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762155096048,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,22 +208,43 @@\n \r\n   return lanes;\r\n };\r\n \r\n-// Cache for branch colors to ensure consistency\r\n-const branchColorCache = new Map();\r\n+// Cache for branch colors to ensure consistency (scoped per GitGraph instance)\r\n+// Using WeakMap so caches are garbage-collected when graphs are discarded\r\n+const branchColorCacheByGraph = new WeakMap();\r\n+// Fallback global cache for callers that don't have a graph key (e.g., Toolbar)\r\n+const globalBranchColorCache = new Map();\r\n \r\n /**\r\n- * Get cached branch color - ensures color consistency across graph and toolbar\r\n+ * Get cached branch color for a specific GitGraph instance - ensures color\r\n+ * consistency within a single graph while avoiding cross-graph coupling.\r\n  * @param {string} branchName - The name of the branch\r\n+ * @param {object} graphKey - The GitGraph instance used as cache key\r\n  * @returns {string} - The cached color for the branch\r\n  */\r\n-export const getCachedBranchColor = (branchName) => {\r\n+export const getCachedBranchColor = (branchName, graphKey) => {\r\n   const key = (branchName || \"\").trim();\r\n-  if (!branchColorCache.has(key)) {\r\n-    branchColorCache.set(key, getBranchColor(key));\r\n+\r\n+  // If no graph key provided, fall back to a shared cache (used by UI chrome)\r\n+  if (!graphKey || (typeof graphKey !== \"object\" && typeof graphKey !== \"function\")) {\r\n+    if (!globalBranchColorCache.has(key)) {\r\n+      globalBranchColorCache.set(key, getBranchColor(key));\r\n+    }\r\n+    return globalBranchColorCache.get(key);\r\n   }\r\n-  return branchColorCache.get(key);\r\n+\r\n+  // Resolve cache map for this graph\r\n+  let cache = branchColorCacheByGraph.get(graphKey);\r\n+  if (!cache) {\r\n+    cache = new Map();\r\n+    branchColorCacheByGraph.set(graphKey, cache);\r\n+  }\r\n+\r\n+  if (!cache.has(key)) {\r\n+    cache.set(key, getBranchColor(key));\r\n+  }\r\n+  return cache.get(key);\r\n };\r\n \r\n /**\r\n  * Convert Git graph to React Flow nodes and edges\r\n@@ -255,9 +276,9 @@\n     y: 120, // Fixed vertical spacing between lanes\r\n   };\r\n \r\n   // Calculate vertical offset to center the graph\r\n-  const verticalOffset = 100 - (minLane * nodeSpacing.y);\r\n+  const verticalOffset = 100 - minLane * nodeSpacing.y;\r\n \r\n   // Create nodes - LEFT TO RIGHT layout\r\n   const nodes = [];\r\n \r\n@@ -270,16 +291,19 @@\n     const branchColors = {}; // Map branch names to their colors\r\n     for (const [branchName, branchCommitId] of branches) {\r\n       if (branchCommitId === id) {\r\n         commitBranches.push(branchName);\r\n-        branchColors[branchName] = getCachedBranchColor(branchName);\r\n+        branchColors[branchName] = getCachedBranchColor(\r\n+          branchName,\r\n+          gitGraph\r\n+        );\r\n       }\r\n     }\r\n \r\n     // Use the branch that CREATED this commit for persistent color\r\n     // This ensures commits keep their color even after branch moves\r\n-    const creatingBranch = commit.createdByBranch || \"main\";\r\n-    const color = getCachedBranchColor(creatingBranch);\r\n+  const creatingBranch = commit.createdByBranch || \"main\";\r\n+  const color = getCachedBranchColor(creatingBranch, gitGraph);\r\n \r\n     // Check if this is the HEAD commit\r\n     const isHead = commitBranches.includes(HEAD);\r\n \r\n"
                }
            ],
            "date": 1762148705486,
            "name": "Commit-0",
            "content": "/**\r\n * Graph Layout Utilities\r\n * Uses BFS algorithm to calculate node positions for the commit graph\r\n */\r\n\r\n/**\r\n * Convert HSL to HEX for consistent usage in UI (e.g., box-shadows expect HEX with alpha)\r\n */\r\nconst hslToHex = (h, s, l) => {\r\n  // h: 0-360, s: 0-100, l: 0-100\r\n  s /= 100;\r\n  l /= 100;\r\n  const k = (n) => (n + h / 30) % 12;\r\n  const a = s * Math.min(l, 1 - l);\r\n  const f = (n) =>\r\n    l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));\r\n  const toHex = (x) =>\r\n    Math.round(255 * x)\r\n      .toString(16)\r\n      .padStart(2, \"0\");\r\n  return `#${toHex(f(0))}${toHex(f(8))}${toHex(f(4))}`;\r\n};\r\n\r\n/**\r\n * Stable string hash -> 32-bit unsigned int\r\n */\r\nconst hashString = (str) => {\r\n  let hash = 5381;\r\n  for (let i = 0; i < str.length; i++) {\r\n    hash = (hash * 33) ^ str.charCodeAt(i);\r\n  }\r\n  return hash >>> 0; // ensure unsigned\r\n};\r\n\r\n/**\r\n * Deterministic, high-contrast branch color based on name.\r\n * - Known branch names map to curated, recognizable colors (HEX)\r\n * - Others use golden-angle HSL spread converted to HEX for distinctness\r\n */\r\nexport const getBranchColor = (branchName) => {\r\n  const name = (branchName || \"\").trim();\r\n  const lower = name.toLowerCase();\r\n\r\n  // Curated colors for common branches (distinct and recognizable)\r\n  const fixed = {\r\n    main: \"#3B82F6\", // blue\r\n    master: \"#3B82F6\", // same as main\r\n    develop: \"#22C55E\", // green\r\n    dev: \"#22C55E\",\r\n    hotfix: \"#EF4444\", // red\r\n    release: \"#8B5CF6\", // violet\r\n    feature: \"#F59E0B\", // amber\r\n  };\r\n\r\n  if (fixed[lower]) return fixed[lower];\r\n  if (lower.startsWith(\"feature\")) return fixed.feature;\r\n  if (lower.startsWith(\"hotfix\")) return fixed.hotfix;\r\n  if (lower.startsWith(\"release\")) return fixed.release;\r\n  if (lower.startsWith(\"dev\")) return fixed.develop;\r\n\r\n  // Golden-angle distribution over hue space for clear separation\r\n  // Using fractional part of (hash * phi) for uniform coverage\r\n  const phi = 0.618033988749895; // golden ratio conjugate\r\n  const h = Math.floor(360 * ((hashString(name) * phi) % 1));\r\n  const s = 72; // vivid but not neon\r\n  const l = 52; // good contrast on dark/light glass\r\n  return hslToHex(h, s, l);\r\n};\r\n\r\n/**\r\n * Calculate levels for each commit based on actual timeline (timestamps)\r\n * Levels represent horizontal position (left to right: old to new)\r\n * Ensures commits are positioned chronologically while respecting parent relationships\r\n */\r\nexport const calculateLevels = (commits) => {\r\n  const levels = new Map();\r\n\r\n  // Step 1: Sort all commits by timestamp (oldest first)\r\n  const sortedCommits = Array.from(commits.entries()).sort((a, b) => {\r\n    const timeA = a[1].timestampMs || 0;\r\n    const timeB = b[1].timestampMs || 0;\r\n    return timeA - timeB;\r\n  });\r\n\r\n  // Step 2: Assign initial levels based on chronological order\r\n  sortedCommits.forEach(([id], index) => {\r\n    levels.set(id, index);\r\n  });\r\n\r\n  // Step 3: Adjust levels to ensure child commits are always after ALL parents\r\n  // This is critical for merge commits\r\n  let changed;\r\n  let iterations = 0;\r\n  const maxIterations = commits.size * 2; // Prevent infinite loops\r\n\r\n  do {\r\n    changed = false;\r\n    iterations++;\r\n\r\n    for (const [id, commit] of commits) {\r\n      if (commit.parents.length > 0) {\r\n        const parentLevels = commit.parents\r\n          .map((pid) => levels.get(pid))\r\n          .filter((level) => level !== undefined);\r\n\r\n        if (parentLevels.length > 0) {\r\n          const maxParentLevel = Math.max(...parentLevels);\r\n          const currentLevel = levels.get(id);\r\n\r\n          // Commit must be positioned after its latest parent\r\n          if (currentLevel <= maxParentLevel) {\r\n            levels.set(id, maxParentLevel + 1);\r\n            changed = true;\r\n\r\n            // Push all subsequent commits forward to maintain chronological spacing\r\n            for (const [otherId, otherCommit] of commits) {\r\n              const otherLevel = levels.get(otherId);\r\n              if (\r\n                otherId !== id &&\r\n                otherLevel > currentLevel &&\r\n                otherLevel <= maxParentLevel + 1\r\n              ) {\r\n                if (otherCommit.timestampMs > commit.timestampMs) {\r\n                  levels.set(otherId, otherLevel + 1);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } while (changed && iterations < maxIterations);\r\n\r\n  // Step 4: Compress levels - remove gaps while maintaining order\r\n  const sortedLevels = Array.from(levels.entries()).sort((a, b) => a[1] - b[1]);\r\n\r\n  const compressedLevels = new Map();\r\n  let currentCompressedLevel = 0;\r\n  let lastLevel = -1;\r\n\r\n  sortedLevels.forEach(([id, level]) => {\r\n    if (level !== lastLevel) {\r\n      if (lastLevel !== -1) {\r\n        currentCompressedLevel++;\r\n      }\r\n      lastLevel = level;\r\n    }\r\n    compressedLevels.set(id, currentCompressedLevel);\r\n  });\r\n\r\n  return compressedLevels;\r\n};\r\n\r\n/**\r\n * Assign lanes (vertical positions) with main/master branch centered\r\n * Other branches distributed above and below\r\n * FIXED: Uses a fixed center lane to prevent graph shifting when branches are added\r\n */\r\nconst assignLanes = (commits) => {\r\n  const lanes = new Map();\r\n  const branchLanes = new Map(); // Track which lane each branch uses\r\n\r\n  // Get all unique branch names from commits\r\n  const allBranches = new Set();\r\n  for (const [, commit] of commits) {\r\n    if (commit.createdByBranch) {\r\n      allBranches.add(commit.createdByBranch);\r\n    }\r\n  }\r\n\r\n  const branchNames = Array.from(allBranches);\r\n\r\n  // Find main/master branch index\r\n  let mainIndex = branchNames.findIndex((b) => b === \"main\" || b === \"master\");\r\n  if (mainIndex === -1 && branchNames.length > 0) {\r\n    mainIndex = 0; // If no main/master, use first branch\r\n  }\r\n\r\n  // FIXED: Use a fixed center lane instead of calculating based on branch count\r\n  // This prevents the graph from shifting when new branches are created\r\n  const FIXED_CENTER_LANE = 5; // Fixed center position\r\n\r\n  branchNames.forEach((branchName, index) => {\r\n    if (index === mainIndex) {\r\n      // Main branch gets fixed center lane\r\n      branchLanes.set(branchName, FIXED_CENTER_LANE);\r\n    } else if (index < mainIndex) {\r\n      // Branches before main go above (lower lane numbers)\r\n      branchLanes.set(branchName, FIXED_CENTER_LANE - (mainIndex - index));\r\n    } else {\r\n      // Branches after main go below (higher lane numbers)\r\n      branchLanes.set(branchName, FIXED_CENTER_LANE + (index - mainIndex));\r\n    }\r\n  });\r\n\r\n  // Assign lanes to commits based on which branch created them\r\n  for (const [id, commit] of commits) {\r\n    const branchName = commit.createdByBranch || \"main\";\r\n\r\n    // Get the lane for this branch, default to center if not found\r\n    let lane = branchLanes.get(branchName);\r\n    if (lane === undefined) {\r\n      lane = FIXED_CENTER_LANE;\r\n    }\r\n\r\n    lanes.set(id, lane);\r\n  }\r\n\r\n  return lanes;\r\n};\r\n\r\n// Cache for branch colors to ensure consistency\r\nconst branchColorCache = new Map();\r\n\r\n/**\r\n * Get cached branch color - ensures color consistency across graph and toolbar\r\n * @param {string} branchName - The name of the branch\r\n * @returns {string} - The cached color for the branch\r\n */\r\nexport const getCachedBranchColor = (branchName) => {\r\n  const key = (branchName || \"\").trim();\r\n  if (!branchColorCache.has(key)) {\r\n    branchColorCache.set(key, getBranchColor(key));\r\n  }\r\n  return branchColorCache.get(key);\r\n};\r\n\r\n/**\r\n * Convert Git graph to React Flow nodes and edges\r\n * Layout: Left to Right (old commits on left, new on right)\r\n */\r\nexport const convertToReactFlow = (gitGraph) => {\r\n  const { commits, branches, HEAD, orphanedCommits } = gitGraph;\r\n\r\n  if (commits.size === 0) {\r\n    return { nodes: [], edges: [] };\r\n  }\r\n\r\n  // Calculate levels using BFS (horizontal position)\r\n  const levels = calculateLevels(commits);\r\n\r\n  // Assign lanes for vertical positioning\r\n  const lanes = assignLanes(commits);\r\n\r\n  // FIXED: Calculate spacing to ensure all nodes are visible\r\n  // Find the min and max lanes actually used\r\n  const laneValues = Array.from(lanes.values());\r\n  const minLane = Math.min(...laneValues);\r\n  const maxLane = Math.max(...laneValues);\r\n  const laneRange = maxLane - minLane + 1;\r\n\r\n  // Fixed spacing that works well for most graphs\r\n  const nodeSpacing = {\r\n    x: 200, // Horizontal spacing between commit levels\r\n    y: 120, // Fixed vertical spacing between lanes\r\n  };\r\n\r\n  // Calculate vertical offset to center the graph\r\n  const verticalOffset = 100 - (minLane * nodeSpacing.y);\r\n\r\n  // Create nodes - LEFT TO RIGHT layout\r\n  const nodes = [];\r\n\r\n  for (const [id, commit] of commits) {\r\n    const level = levels.get(id) || 0;\r\n    const lane = lanes.get(id) || 0;\r\n\r\n    // Find branches pointing to this commit\r\n    const commitBranches = [];\r\n    const branchColors = {}; // Map branch names to their colors\r\n    for (const [branchName, branchCommitId] of branches) {\r\n      if (branchCommitId === id) {\r\n        commitBranches.push(branchName);\r\n        branchColors[branchName] = getCachedBranchColor(branchName);\r\n      }\r\n    }\r\n\r\n    // Use the branch that CREATED this commit for persistent color\r\n    // This ensures commits keep their color even after branch moves\r\n    const creatingBranch = commit.createdByBranch || \"main\";\r\n    const color = getCachedBranchColor(creatingBranch);\r\n\r\n    // Check if this is the HEAD commit\r\n    const isHead = commitBranches.includes(HEAD);\r\n\r\n    // Check if this commit is orphaned (after reset, pending garbage collection)\r\n    const isOrphaned = orphanedCommits && orphanedCommits.has(id);\r\n\r\n    nodes.push({\r\n      id,\r\n      type: \"custom\",\r\n      position: {\r\n        x: level * nodeSpacing.x + 150, // Horizontal: left (old) to right (new)\r\n        y: lane * nodeSpacing.y + verticalOffset, // Vertical: fixed lanes with centering offset\r\n      },\r\n      data: {\r\n        commit,\r\n        branches: commitBranches,\r\n        branchColors, // Add branch-specific colors\r\n        color,\r\n        isHead,\r\n        headBranch: HEAD, // Pass HEAD to identify active branch\r\n        isMerge: commit.parents.length > 1,\r\n        isOrphaned, // Mark orphaned commits\r\n      },\r\n    });\r\n  }\r\n\r\n  // Create edges (parent -> child direction, flowing left to right)\r\n  const edges = [];\r\n  for (const [id, commit] of commits) {\r\n    for (let i = 0; i < commit.parents.length; i++) {\r\n      const parentId = commit.parents[i];\r\n      if (commits.has(parentId)) {\r\n        const childNode = nodes.find((n) => n.id === id);\r\n        const parentNode = nodes.find((n) => n.id === parentId);\r\n\r\n        // Determine edge type based on node positions\r\n        const isMainLine = i === 0; // First parent is main line\r\n\r\n        // Check if either end of the edge is orphaned\r\n        const isOrphanedEdge =\r\n          childNode?.data.isOrphaned ||\r\n          false ||\r\n          parentNode?.data.isOrphaned ||\r\n          false;\r\n\r\n        // For main line, use parent's color (continuity)\r\n        // For merge lines, use child's color (showing what's being merged in)\r\n        const edgeColor = isMainLine\r\n          ? parentNode?.data.color || \"#667eea\"\r\n          : childNode?.data.color || \"#667eea\";\r\n\r\n        edges.push({\r\n          id: `${parentId}-${id}`,\r\n          source: parentId, // Parent (older, on left)\r\n          target: id, // Child (newer, on right)\r\n          sourceHandle: null,\r\n          targetHandle: null,\r\n          type: \"custom\", // Use custom edge type for circle markers\r\n          animated: false,\r\n          style: {\r\n            stroke: isOrphanedEdge ? \"#9ca3af\" : edgeColor, // Lighter grey for orphaned edges\r\n            strokeWidth: isOrphanedEdge ? 2 : isMainLine ? 3 : 2.5,\r\n            strokeDasharray: isOrphanedEdge\r\n              ? \"8,8\" // More prominent dashes for orphaned\r\n              : !isMainLine\r\n              ? \"8,4\"\r\n              : undefined,\r\n            opacity: isOrphanedEdge ? 0.4 : isMainLine ? 1 : 0.7, // Slightly more visible\r\n            strokeLinecap: \"round\", // Round line caps for smoother appearance\r\n          },\r\n          // Remove markerEnd to eliminate arrowheads - you can add circles via CSS or custom component\r\n          markerEnd: undefined,\r\n          data: {\r\n            isOrphaned: isOrphanedEdge, // Mark orphaned edges\r\n          },\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  return { nodes, edges };\r\n};\r\n\r\n/**\r\n * Get list of all branches\r\n */\r\nexport const getAllBranches = (branches) => {\r\n  return Array.from(branches.keys());\r\n};\r\n"
        }
    ]
}