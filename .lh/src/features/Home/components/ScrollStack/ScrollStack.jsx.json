{
    "sourceFile": "src/features/Home/components/ScrollStack/ScrollStack.jsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1761549143257,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761550008652,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,313 +1,77 @@\n-import { useLayoutEffect, useRef, useCallback } from 'react';\r\n-import Lenis from 'lenis';\r\n-import './ScrollStack.css';\r\n+import { useEffect, useRef } from \"react\";\r\n+import Lenis from \"lenis\";\r\n+import \"./ScrollStack.css\";\r\n \r\n-export const ScrollStackItem = ({ children, itemClassName = '' }) => (\r\n-  <div className={`scroll-stack-card ${itemClassName}`.trim()}>{children}</div>\r\n+export const ScrollStackItem = ({ children }) => (\r\n+  <div className=\"scroll-stack-card\">{children}</div>\r\n );\r\n \r\n const ScrollStack = ({\r\n   children,\r\n-  className = '',\r\n-  itemDistance = 100,\r\n-  itemScale = 0.03,\r\n-  itemStackDistance = 30,\r\n-  stackPosition = '20%',\r\n-  scaleEndPosition = '10%',\r\n-  baseScale = 0.85,\r\n-  scaleDuration = 0.5,\r\n-  rotationAmount = 0,\r\n-  blurAmount = 0,\r\n-  useWindowScroll = false,\r\n-  onStackComplete\r\n+  itemDistance = 150,\r\n+  scaleStep = 0.05,\r\n+  baseScale = 0.9,\r\n+  fadeOut = true,\r\n }) => {\r\n-  const scrollerRef = useRef(null);\r\n-  const stackCompletedRef = useRef(false);\r\n-  const animationFrameRef = useRef(null);\r\n+  const containerRef = useRef(null);\r\n+  const cardsRef = useRef([]);\r\n   const lenisRef = useRef(null);\r\n-  const cardsRef = useRef([]);\r\n-  const lastTransformsRef = useRef(new Map());\r\n-  const isUpdatingRef = useRef(false);\r\n+  const frameRef = useRef(null);\r\n \r\n-  const calculateProgress = useCallback((scrollTop, start, end) => {\r\n-    if (scrollTop < start) return 0;\r\n-    if (scrollTop > end) return 1;\r\n-    return (scrollTop - start) / (end - start);\r\n-  }, []);\r\n+  useEffect(() => {\r\n+    const container = containerRef.current;\r\n+    const cards = Array.from(container.querySelectorAll(\".scroll-stack-card\"));\r\n+    cardsRef.current = cards;\r\n \r\n-  const parsePercentage = useCallback((value, containerHeight) => {\r\n-    if (typeof value === 'string' && value.includes('%')) {\r\n-      return (parseFloat(value) / 100) * containerHeight;\r\n-    }\r\n-    return parseFloat(value);\r\n-  }, []);\r\n+    // Initial placement\r\n+    cards.forEach((card, i) => {\r\n+      card.style.zIndex = cards.length - i;\r\n+      card.style.transform = `translateY(${i * itemDistance}px) scale(${\r\n+        baseScale - i * scaleStep\r\n+      })`;\r\n+      card.style.opacity = 1 - i * 0.1;\r\n+    });\r\n \r\n-  const getScrollData = useCallback(() => {\r\n-    if (useWindowScroll) {\r\n-      return {\r\n-        scrollTop: window.scrollY,\r\n-        containerHeight: window.innerHeight,\r\n-        scrollContainer: document.documentElement\r\n-      };\r\n-    } else {\r\n-      const scroller = scrollerRef.current;\r\n-      return {\r\n-        scrollTop: scroller.scrollTop,\r\n-        containerHeight: scroller.clientHeight,\r\n-        scrollContainer: scroller\r\n-      };\r\n-    }\r\n-  }, [useWindowScroll]);\r\n-\r\n-  const getElementOffset = useCallback(\r\n-    element => {\r\n-      if (useWindowScroll) {\r\n-        const rect = element.getBoundingClientRect();\r\n-        return rect.top + window.scrollY;\r\n-      } else {\r\n-        return element.offsetTop;\r\n-      }\r\n-    },\r\n-    [useWindowScroll]\r\n-  );\r\n-\r\n-  const updateCardTransforms = useCallback(() => {\r\n-    if (!cardsRef.current.length || isUpdatingRef.current) return;\r\n-\r\n-    isUpdatingRef.current = true;\r\n-\r\n-    const { scrollTop, containerHeight, scrollContainer } = getScrollData();\r\n-    const stackPositionPx = parsePercentage(stackPosition, containerHeight);\r\n-    const scaleEndPositionPx = parsePercentage(scaleEndPosition, containerHeight);\r\n-\r\n-    const endElement = useWindowScroll\r\n-      ? document.querySelector('.scroll-stack-end')\r\n-      : scrollerRef.current?.querySelector('.scroll-stack-end');\r\n-\r\n-    const endElementTop = endElement ? getElementOffset(endElement) : 0;\r\n-\r\n-    cardsRef.current.forEach((card, i) => {\r\n-      if (!card) return;\r\n-\r\n-      const cardTop = getElementOffset(card);\r\n-      const triggerStart = cardTop - stackPositionPx - itemStackDistance * i;\r\n-      const triggerEnd = cardTop - scaleEndPositionPx;\r\n-      const pinStart = cardTop - stackPositionPx - itemStackDistance * i;\r\n-      const pinEnd = endElementTop - containerHeight / 2;\r\n-\r\n-      const scaleProgress = calculateProgress(scrollTop, triggerStart, triggerEnd);\r\n-      const targetScale = baseScale + i * itemScale;\r\n-      const scale = 1 - scaleProgress * (1 - targetScale);\r\n-      const rotation = rotationAmount ? i * rotationAmount * scaleProgress : 0;\r\n-\r\n-      let blur = 0;\r\n-      if (blurAmount) {\r\n-        let topCardIndex = 0;\r\n-        for (let j = 0; j < cardsRef.current.length; j++) {\r\n-          const jCardTop = getElementOffset(cardsRef.current[j]);\r\n-          const jTriggerStart = jCardTop - stackPositionPx - itemStackDistance * j;\r\n-          if (scrollTop >= jTriggerStart) {\r\n-            topCardIndex = j;\r\n-          }\r\n-        }\r\n-\r\n-        if (i < topCardIndex) {\r\n-          const depthInStack = topCardIndex - i;\r\n-          blur = Math.max(0, depthInStack * blurAmount);\r\n-        }\r\n-      }\r\n-\r\n-      let translateY = 0;\r\n-      const isPinned = scrollTop >= pinStart && scrollTop <= pinEnd;\r\n-\r\n-      if (isPinned) {\r\n-        translateY = scrollTop - cardTop + stackPositionPx + itemStackDistance * i;\r\n-      } else if (scrollTop > pinEnd) {\r\n-        translateY = pinEnd - cardTop + stackPositionPx + itemStackDistance * i;\r\n-      }\r\n-\r\n-      const newTransform = {\r\n-        translateY: Math.round(translateY * 100) / 100,\r\n-        scale: Math.round(scale * 1000) / 1000,\r\n-        rotation: Math.round(rotation * 100) / 100,\r\n-        blur: Math.round(blur * 100) / 100\r\n-      };\r\n-\r\n-      const lastTransform = lastTransformsRef.current.get(i);\r\n-      const hasChanged =\r\n-        !lastTransform ||\r\n-        Math.abs(lastTransform.translateY - newTransform.translateY) > 0.1 ||\r\n-        Math.abs(lastTransform.scale - newTransform.scale) > 0.001 ||\r\n-        Math.abs(lastTransform.rotation - newTransform.rotation) > 0.1 ||\r\n-        Math.abs(lastTransform.blur - newTransform.blur) > 0.1;\r\n-\r\n-      if (hasChanged) {\r\n-        const transform = `translate3d(0, ${newTransform.translateY}px, 0) scale(${newTransform.scale}) rotate(${newTransform.rotation}deg)`;\r\n-        const filter = newTransform.blur > 0 ? `blur(${newTransform.blur}px)` : '';\r\n-\r\n-        card.style.transform = transform;\r\n-        card.style.filter = filter;\r\n-\r\n-        lastTransformsRef.current.set(i, newTransform);\r\n-      }\r\n-\r\n-      if (i === cardsRef.current.length - 1) {\r\n-        const isInView = scrollTop >= pinStart && scrollTop <= pinEnd;\r\n-        if (isInView && !stackCompletedRef.current) {\r\n-          stackCompletedRef.current = true;\r\n-          onStackComplete?.();\r\n-        } else if (!isInView && stackCompletedRef.current) {\r\n-          stackCompletedRef.current = false;\r\n-        }\r\n-      }\r\n+    // Setup Lenis smooth scroll\r\n+    const lenis = new Lenis({\r\n+      duration: 1.1,\r\n+      smoothWheel: true,\r\n+      syncTouch: true,\r\n     });\r\n+    lenisRef.current = lenis;\r\n \r\n-    isUpdatingRef.current = false;\r\n-  }, [\r\n-    itemScale,\r\n-    itemStackDistance,\r\n-    stackPosition,\r\n-    scaleEndPosition,\r\n-    baseScale,\r\n-    rotationAmount,\r\n-    blurAmount,\r\n-    useWindowScroll,\r\n-    onStackComplete,\r\n-    calculateProgress,\r\n-    parsePercentage,\r\n-    getScrollData,\r\n-    getElementOffset\r\n-  ]);\r\n+    const update = (time) => {\r\n+      lenis.raf(time);\r\n+      frameRef.current = requestAnimationFrame(update);\r\n \r\n-  const handleScroll = useCallback(() => {\r\n-    updateCardTransforms();\r\n-  }, [updateCardTransforms]);\r\n+      const scroll = lenis.scroll;\r\n+      const viewportH = window.innerHeight;\r\n \r\n-  const setupLenis = useCallback(() => {\r\n-    if (useWindowScroll) {\r\n-      const lenis = new Lenis({\r\n-        duration: 1.2,\r\n-        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\r\n-        smoothWheel: true,\r\n-        touchMultiplier: 2,\r\n-        infinite: false,\r\n-        wheelMultiplier: 1,\r\n-        lerp: 0.1,\r\n-        syncTouch: true,\r\n-        syncTouchLerp: 0.075\r\n-      });\r\n+      cards.forEach((card, i) => {\r\n+        const rect = card.getBoundingClientRect();\r\n+        const progress = Math.min(Math.max(1 - rect.top / viewportH, 0), 1);\r\n \r\n-      lenis.on('scroll', handleScroll);\r\n+        const translateY = i * itemDistance - progress * itemDistance;\r\n+        const scale = baseScale - i * scaleStep + progress * scaleStep;\r\n+        const opacity = fadeOut ? 1 - progress * 0.6 : 1;\r\n \r\n-      const raf = time => {\r\n-        lenis.raf(time);\r\n-        animationFrameRef.current = requestAnimationFrame(raf);\r\n-      };\r\n-      animationFrameRef.current = requestAnimationFrame(raf);\r\n-\r\n-      lenisRef.current = lenis;\r\n-      return lenis;\r\n-    } else {\r\n-      const scroller = scrollerRef.current;\r\n-      if (!scroller) return;\r\n-\r\n-      const lenis = new Lenis({\r\n-        wrapper: scroller,\r\n-        content: scroller.querySelector('.scroll-stack-inner'),\r\n-        duration: 1.2,\r\n-        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\r\n-        smoothWheel: true,\r\n-        touchMultiplier: 2,\r\n-        infinite: false,\r\n-        gestureOrientationHandler: true,\r\n-        normalizeWheel: true,\r\n-        wheelMultiplier: 1,\r\n-        touchInertiaMultiplier: 35,\r\n-        lerp: 0.1,\r\n-        syncTouch: true,\r\n-        syncTouchLerp: 0.075,\r\n-        touchInertia: 0.6\r\n+        card.style.transform = `translateY(${translateY}px) scale(${scale})`;\r\n+        card.style.opacity = opacity;\r\n       });\r\n+    };\r\n \r\n-      lenis.on('scroll', handleScroll);\r\n+    frameRef.current = requestAnimationFrame(update);\r\n \r\n-      const raf = time => {\r\n-        lenis.raf(time);\r\n-        animationFrameRef.current = requestAnimationFrame(raf);\r\n-      };\r\n-      animationFrameRef.current = requestAnimationFrame(raf);\r\n-\r\n-      lenisRef.current = lenis;\r\n-      return lenis;\r\n-    }\r\n-  }, [handleScroll, useWindowScroll]);\r\n-\r\n-  useLayoutEffect(() => {\r\n-    const scroller = scrollerRef.current;\r\n-    if (!scroller) return;\r\n-\r\n-    const cards = Array.from(\r\n-      useWindowScroll\r\n-        ? document.querySelectorAll('.scroll-stack-card')\r\n-        : scroller.querySelectorAll('.scroll-stack-card')\r\n-    );\r\n-\r\n-    cardsRef.current = cards;\r\n-    const transformsCache = lastTransformsRef.current;\r\n-\r\n-    cards.forEach((card, i) => {\r\n-      if (i < cards.length - 1) {\r\n-        card.style.marginBottom = `${itemDistance}px`;\r\n-      }\r\n-      card.style.willChange = 'transform, filter';\r\n-      card.style.transformOrigin = 'top center';\r\n-      card.style.backfaceVisibility = 'hidden';\r\n-      card.style.transform = 'translateZ(0)';\r\n-      card.style.webkitTransform = 'translateZ(0)';\r\n-      card.style.perspective = '1000px';\r\n-      card.style.webkitPerspective = '1000px';\r\n-    });\r\n-\r\n-    setupLenis();\r\n-\r\n-    updateCardTransforms();\r\n-\r\n     return () => {\r\n-      if (animationFrameRef.current) {\r\n-        cancelAnimationFrame(animationFrameRef.current);\r\n-      }\r\n-      if (lenisRef.current) {\r\n-        lenisRef.current.destroy();\r\n-      }\r\n-      stackCompletedRef.current = false;\r\n-      cardsRef.current = [];\r\n-      transformsCache.clear();\r\n-      isUpdatingRef.current = false;\r\n+      cancelAnimationFrame(frameRef.current);\r\n+      lenis.destroy();\r\n     };\r\n-  }, [\r\n-    itemDistance,\r\n-    itemScale,\r\n-    itemStackDistance,\r\n-    stackPosition,\r\n-    scaleEndPosition,\r\n-    baseScale,\r\n-    scaleDuration,\r\n-    rotationAmount,\r\n-    blurAmount,\r\n-    useWindowScroll,\r\n-    onStackComplete,\r\n-    setupLenis,\r\n-    updateCardTransforms\r\n-  ]);\r\n+  }, [itemDistance, scaleStep, baseScale, fadeOut]);\r\n \r\n   return (\r\n-    <div className={`scroll-stack-scroller ${className}`.trim()} ref={scrollerRef}>\r\n-      <div className=\"scroll-stack-inner\">\r\n-        {children}\r\n-        {/* Spacer so the last pin can release cleanly */}\r\n-        <div className=\"scroll-stack-end\" />\r\n-      </div>\r\n+    <div className=\"scroll-stack-container\" ref={containerRef}>\r\n+      <div className=\"scroll-stack-inner\">{children}</div>\r\n     </div>\r\n   );\r\n };\r\n \r\n"
                },
                {
                    "date": 1761550199260,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,71 +7,60 @@\n );\r\n \r\n const ScrollStack = ({\r\n   children,\r\n-  itemDistance = 150,\r\n+  baseScale = 0.9,\r\n   scaleStep = 0.05,\r\n-  baseScale = 0.9,\r\n-  fadeOut = true,\r\n+  itemDistance = 100,\r\n }) => {\r\n   const containerRef = useRef(null);\r\n+  const lenisRef = useRef(null);\r\n   const cardsRef = useRef([]);\r\n-  const lenisRef = useRef(null);\r\n-  const frameRef = useRef(null);\r\n \r\n   useEffect(() => {\r\n     const container = containerRef.current;\r\n     const cards = Array.from(container.querySelectorAll(\".scroll-stack-card\"));\r\n     cardsRef.current = cards;\r\n \r\n-    // Initial placement\r\n-    cards.forEach((card, i) => {\r\n-      card.style.zIndex = cards.length - i;\r\n-      card.style.transform = `translateY(${i * itemDistance}px) scale(${\r\n-        baseScale - i * scaleStep\r\n-      })`;\r\n-      card.style.opacity = 1 - i * 0.1;\r\n-    });\r\n-\r\n-    // Setup Lenis smooth scroll\r\n-    const lenis = new Lenis({\r\n-      duration: 1.1,\r\n-      smoothWheel: true,\r\n-      syncTouch: true,\r\n-    });\r\n+    const lenis = new Lenis({ duration: 1.1, smoothWheel: true });\r\n     lenisRef.current = lenis;\r\n \r\n     const update = (time) => {\r\n       lenis.raf(time);\r\n-      frameRef.current = requestAnimationFrame(update);\r\n \r\n-      const scroll = lenis.scroll;\r\n-      const viewportH = window.innerHeight;\r\n+      const rect = container.getBoundingClientRect();\r\n+      const totalScroll = window.innerHeight * (cards.length - 1);\r\n+      const progress = Math.min(Math.max(-rect.top / totalScroll, 0), 1);\r\n \r\n       cards.forEach((card, i) => {\r\n-        const rect = card.getBoundingClientRect();\r\n-        const progress = Math.min(Math.max(1 - rect.top / viewportH, 0), 1);\r\n+        const cardProgress = Math.min(Math.max(progress * cards.length - i, 0), 1);\r\n+        const translateY = cardProgress * itemDistance;\r\n+        const scale = baseScale + cardProgress * scaleStep;\r\n+        const opacity = 1 - cardProgress * 0.7;\r\n \r\n-        const translateY = i * itemDistance - progress * itemDistance;\r\n-        const scale = baseScale - i * scaleStep + progress * scaleStep;\r\n-        const opacity = fadeOut ? 1 - progress * 0.6 : 1;\r\n-\r\n         card.style.transform = `translateY(${translateY}px) scale(${scale})`;\r\n         card.style.opacity = opacity;\r\n       });\r\n+\r\n+      requestAnimationFrame(update);\r\n     };\r\n \r\n-    frameRef.current = requestAnimationFrame(update);\r\n+    requestAnimationFrame(update);\r\n \r\n     return () => {\r\n-      cancelAnimationFrame(frameRef.current);\r\n       lenis.destroy();\r\n     };\r\n-  }, [itemDistance, scaleStep, baseScale, fadeOut]);\r\n+  }, [baseScale, scaleStep, itemDistance]);\r\n \r\n   return (\r\n-    <div className=\"scroll-stack-container\" ref={containerRef}>\r\n-      <div className=\"scroll-stack-inner\">{children}</div>\r\n+    <div\r\n+      className=\"scroll-stack-wrapper\"\r\n+      ref={containerRef}\r\n+      style={{ height: `${children.length * 100}vh` }}\r\n+    >\r\n+      <div className=\"scroll-stack-sticky\">\r\n+        {children}\r\n+      </div>\r\n     </div>\r\n   );\r\n };\r\n \r\n"
                },
                {
                    "date": 1761550322599,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,56 +1,80 @@\n import { useEffect, useRef } from \"react\";\r\n import Lenis from \"lenis\";\r\n import \"./ScrollStack.css\";\r\n \r\n-export const ScrollStackItem = ({ children }) => (\r\n-  <div className=\"scroll-stack-card\">{children}</div>\r\n-);\r\n+export const ScrollStackItem = ({ children }) => {\r\n+  return <div className=\"scroll-stack-card\">{children}</div>;\r\n+};\r\n \r\n const ScrollStack = ({\r\n   children,\r\n+  itemSpacing = 120,\r\n+  scaleStep = 0.05,\r\n   baseScale = 0.9,\r\n-  scaleStep = 0.05,\r\n-  itemDistance = 100,\r\n+  colourStep = 30,\r\n }) => {\r\n   const containerRef = useRef(null);\r\n+  const cardsRef = useRef([]);\r\n   const lenisRef = useRef(null);\r\n-  const cardsRef = useRef([]);\r\n+  const rafRef = useRef(null);\r\n \r\n   useEffect(() => {\r\n     const container = containerRef.current;\r\n+    if (!container) return;\r\n+\r\n     const cards = Array.from(container.querySelectorAll(\".scroll-stack-card\"));\r\n     cardsRef.current = cards;\r\n \r\n-    const lenis = new Lenis({ duration: 1.1, smoothWheel: true });\r\n+    // Set initial stack: newer (last) on top at start\r\n+    cards.forEach((card, index) => {\r\n+      const scale = baseScale - index * scaleStep;\r\n+      const yOffset = index * itemSpacing;\r\n+      const colourHue = (index * colourStep) % 360;\r\n+      card.style.transform = `translateY(${yOffset}px) scale(${scale})`;\r\n+      card.style.zIndex = cards.length - index;\r\n+      card.style.background = `hsl(${colourHue}, 70%, 85%)`;\r\n+      card.style.opacity = 1;\r\n+    });\r\n+\r\n+    // Initialise Lenis for smooth scrolling\r\n+    const lenis = new Lenis({\r\n+      duration: 1.2,\r\n+      smoothWheel: true,\r\n+      smoothTouch: true,\r\n+    });\r\n     lenisRef.current = lenis;\r\n \r\n     const update = (time) => {\r\n       lenis.raf(time);\r\n \r\n-      const rect = container.getBoundingClientRect();\r\n-      const totalScroll = window.innerHeight * (cards.length - 1);\r\n-      const progress = Math.min(Math.max(-rect.top / totalScroll, 0), 1);\r\n+      const scrollTop = lenis.scroll;\r\n+      const viewportH = window.innerHeight;\r\n+      const totalDistance = itemSpacing * (cards.length - 1);\r\n \r\n       cards.forEach((card, i) => {\r\n-        const cardProgress = Math.min(Math.max(progress * cards.length - i, 0), 1);\r\n-        const translateY = cardProgress * itemDistance;\r\n-        const scale = baseScale + cardProgress * scaleStep;\r\n-        const opacity = 1 - cardProgress * 0.7;\r\n+        // progress from 0 → 1 where card moves into full view\r\n+        const start = i * itemSpacing;\r\n+        const progress = Math.min(Math.max((scrollTop - start) / totalDistance, 0), 1);\r\n \r\n+        const translateY = (i * itemSpacing) - progress * totalDistance;\r\n+        const scale = baseScale - i * scaleStep + progress * (scaleStep * i);\r\n+        const opacity = 1 - progress * 0.6;\r\n+\r\n         card.style.transform = `translateY(${translateY}px) scale(${scale})`;\r\n         card.style.opacity = opacity;\r\n       });\r\n \r\n-      requestAnimationFrame(update);\r\n+      rafRef.current = requestAnimationFrame(update);\r\n     };\r\n \r\n-    requestAnimationFrame(update);\r\n+    rafRef.current = requestAnimationFrame(update);\r\n \r\n     return () => {\r\n+      cancelAnimationFrame(rafRef.current);\r\n       lenis.destroy();\r\n     };\r\n-  }, [baseScale, scaleStep, itemDistance]);\r\n+  }, [itemSpacing, scaleStep, baseScale, colourStep]);\r\n \r\n   return (\r\n     <div\r\n       className=\"scroll-stack-wrapper\"\r\n"
                },
                {
                    "date": 1761550793404,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,89 +1,128 @@\n-import { useEffect, useRef } from \"react\";\r\n-import Lenis from \"lenis\";\r\n+// src/yourpath/components/ScrollStack/ScrollStack.jsx\r\n+import React, { useRef, useEffect } from \"react\";\r\n import \"./ScrollStack.css\";\r\n \r\n-export const ScrollStackItem = ({ children }) => {\r\n-  return <div className=\"scroll-stack-card\">{children}</div>;\r\n-};\r\n-\r\n+/**\r\n+ * Simple ScrollStack: window-scroll based\r\n+ * - children should be ScrollStackItem wrappers (or any block-level elements)\r\n+ * - stackTop: px from top where cards stick (default 20vh)\r\n+ * - spacing: vertical spacing between stacked cards (px)\r\n+ */\r\n const ScrollStack = ({\r\n   children,\r\n-  itemSpacing = 120,\r\n-  scaleStep = 0.05,\r\n-  baseScale = 0.9,\r\n-  colourStep = 30,\r\n+  stackTop = \"20vh\",\r\n+  spacing = 40,\r\n+  scaleStep = 0.03,\r\n+  className = \"\",\r\n }) => {\r\n   const containerRef = useRef(null);\r\n-  const cardsRef = useRef([]);\r\n-  const lenisRef = useRef(null);\r\n-  const rafRef = useRef(null);\r\n+  const itemsRef = useRef([]);\r\n \r\n+  // keep itemsRef in sync with children length\r\n+  itemsRef.current = [];\r\n+\r\n   useEffect(() => {\r\n     const container = containerRef.current;\r\n     if (!container) return;\r\n \r\n     const cards = Array.from(container.querySelectorAll(\".scroll-stack-card\"));\r\n-    cardsRef.current = cards;\r\n+    const n = cards.length;\r\n+    if (n === 0) return;\r\n \r\n-    // Set initial stack: newer (last) on top at start\r\n-    cards.forEach((card, index) => {\r\n-      const scale = baseScale - index * scaleStep;\r\n-      const yOffset = index * itemSpacing;\r\n-      const colourHue = (index * colourStep) % 360;\r\n-      card.style.transform = `translateY(${yOffset}px) scale(${scale})`;\r\n-      card.style.zIndex = cards.length - index;\r\n-      card.style.background = `hsl(${colourHue}, 70%, 85%)`;\r\n-      card.style.opacity = 1;\r\n-    });\r\n+    // set container min-height so there's enough scroll space to stack all cards\r\n+    // formula: viewportHeight * (n + 1) gives room for each card to pin then release\r\n+    const vh = window.innerHeight;\r\n+    container.style.minHeight = `${vh * (n + 1)}px`;\r\n \r\n-    // Initialise Lenis for smooth scrolling\r\n-    const lenis = new Lenis({\r\n-      duration: 1.2,\r\n-      smoothWheel: true,\r\n-      smoothTouch: true,\r\n+    // set each card wrapper to sticky and give proper z-index so top card is last child\r\n+    cards.forEach((card, i) => {\r\n+      const idxFromBottom = i; // order as in DOM: first card is bottom-most\r\n+      card.style.position = \"sticky\";\r\n+      card.style.top = stackTop;\r\n+      card.style.zIndex = `${1000 - i}`; // later children visually in front if they come later in DOM\r\n+      card.dataset.stackIndex = i;\r\n+      // initial transform / scale\r\n+      card.style.transform = `translateY(${idxFromBottom * spacing}px) scale(${1 - idxFromBottom * scaleStep})`;\r\n     });\r\n-    lenisRef.current = lenis;\r\n \r\n-    const update = (time) => {\r\n-      lenis.raf(time);\r\n+    // scroll handler: compute progress through container and update translate for each card\r\n+    let rafId = null;\r\n+    const handle = () => {\r\n+      if (rafId) cancelAnimationFrame(rafId);\r\n+      rafId = requestAnimationFrame(() => {\r\n+        const rect = container.getBoundingClientRect();\r\n+        // distance scrolled into container (0 .. containerScrollableHeight)\r\n+        const containerTopToViewport = Math.max(0, -rect.top);\r\n+        const containerHeight = rect.height;\r\n+        const progress = Math.min(1, Math.max(0, containerTopToViewport / (containerHeight - vh)));\r\n \r\n-      const scrollTop = lenis.scroll;\r\n-      const viewportH = window.innerHeight;\r\n-      const totalDistance = itemSpacing * (cards.length - 1);\r\n+        // For each card, compute how far it should `rise` into the stack\r\n+        cards.forEach((card, i) => {\r\n+          // Each card becomes active a little later:\r\n+          const cardActivation = i / n; // 0 .. <1\r\n+          let localProgress = (progress - cardActivation) / (1 / n);\r\n+          localProgress = Math.min(1, Math.max(0, localProgress));\r\n \r\n-      cards.forEach((card, i) => {\r\n-        // progress from 0 → 1 where card moves into full view\r\n-        const start = i * itemSpacing;\r\n-        const progress = Math.min(Math.max((scrollTop - start) / totalDistance, 0), 1);\r\n+          // move card upward by spacing * (1 - localRemaining)\r\n+          // baseline translate = spacing * index (gives offset for stack)\r\n+          const baseOffset = i * spacing;\r\n+          // when localProgress reaches 1 -> card should be at top position (0 offset)\r\n+          const offset = Math.round((1 - localProgress) * baseOffset);\r\n \r\n-        const translateY = (i * itemSpacing) - progress * totalDistance;\r\n-        const scale = baseScale - i * scaleStep + progress * (scaleStep * i);\r\n-        const opacity = 1 - progress * 0.6;\r\n+          // scale effect\r\n+          const baseScale = 1 - i * scaleStep;\r\n+          const scale = baseScale + (1 - baseScale) * localProgress * 0.08; // tiny pop as active\r\n \r\n-        card.style.transform = `translateY(${translateY}px) scale(${scale})`;\r\n-        card.style.opacity = opacity;\r\n+          // subtle elevation (box-shadow) while active\r\n+          const elev = Math.round(localProgress * 12);\r\n+\r\n+          card.style.transform = `translateY(${offset}px) scale(${scale})`;\r\n+          card.style.boxShadow = `0 ${4 + elev}px ${18 + elev}px rgba(12,16,24,${0.08 + localProgress * 0.06})`;\r\n+          card.style.opacity = `${0.7 + 0.3 * localProgress}`;\r\n+        });\r\n       });\r\n-\r\n-      rafRef.current = requestAnimationFrame(update);\r\n     };\r\n \r\n-    rafRef.current = requestAnimationFrame(update);\r\n+    // initial paint\r\n+    handle();\r\n \r\n+    window.addEventListener(\"scroll\", handle, { passive: true });\r\n+    window.addEventListener(\"resize\", handle);\r\n+\r\n     return () => {\r\n-      cancelAnimationFrame(rafRef.current);\r\n-      lenis.destroy();\r\n+      if (rafId) cancelAnimationFrame(rafId);\r\n+      window.removeEventListener(\"scroll\", handle);\r\n+      window.removeEventListener(\"resize\", handle);\r\n+      // cleanup inline styles we added\r\n+      container.style.minHeight = \"\";\r\n+      cards.forEach((card) => {\r\n+        card.style.position = \"\";\r\n+        card.style.top = \"\";\r\n+        card.style.zIndex = \"\";\r\n+        card.style.transform = \"\";\r\n+        card.style.boxShadow = \"\";\r\n+        card.style.opacity = \"\";\r\n+      });\r\n     };\r\n-  }, [itemSpacing, scaleStep, baseScale, colourStep]);\r\n+  }, [stackTop, spacing, scaleStep, children]);\r\n \r\n+  // render children wrapped in wrapper that has .scroll-stack-card\r\n+  // If user already passed ScrollStackItem components with that class, we will keep them as-is.\r\n   return (\r\n-    <div\r\n-      className=\"scroll-stack-wrapper\"\r\n-      ref={containerRef}\r\n-      style={{ height: `${children.length * 100}vh` }}\r\n-    >\r\n-      <div className=\"scroll-stack-sticky\">\r\n-        {children}\r\n+    <div className={`scroll-stack-container ${className}`} ref={containerRef}>\r\n+      <div className=\"scroll-stack-inner\">\r\n+        {React.Children.map(children, (child, i) => {\r\n+          // if the child already has class .scroll-stack-card, return as is (useful if using ScrollStackItem)\r\n+          if (child && child.props && String(child.props.className || \"\").includes(\"scroll-stack-card\")) {\r\n+            return child;\r\n+          }\r\n+          return (\r\n+            <div className=\"scroll-stack-card\">\r\n+              {child}\r\n+            </div>\r\n+          );\r\n+        })}\r\n       </div>\r\n     </div>\r\n   );\r\n };\r\n"
                },
                {
                    "date": 1761551249042,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,130 +1,55 @@\n-// src/yourpath/components/ScrollStack/ScrollStack.jsx\r\n-import React, { useRef, useEffect } from \"react\";\r\n+import React, { useEffect, useRef } from \"react\";\r\n import \"./ScrollStack.css\";\r\n \r\n-/**\r\n- * Simple ScrollStack: window-scroll based\r\n- * - children should be ScrollStackItem wrappers (or any block-level elements)\r\n- * - stackTop: px from top where cards stick (default 20vh)\r\n- * - spacing: vertical spacing between stacked cards (px)\r\n- */\r\n-const ScrollStack = ({\r\n-  children,\r\n-  stackTop = \"20vh\",\r\n-  spacing = 40,\r\n-  scaleStep = 0.03,\r\n-  className = \"\",\r\n-}) => {\r\n+const ScrollStack = ({ children, stackTop = \"10vh\" }) => {\r\n   const containerRef = useRef(null);\r\n-  const itemsRef = useRef([]);\r\n+  const cardsRef = useRef([]);\r\n \r\n-  // keep itemsRef in sync with children length\r\n-  itemsRef.current = [];\r\n-\r\n   useEffect(() => {\r\n     const container = containerRef.current;\r\n-    if (!container) return;\r\n-\r\n-    const cards = Array.from(container.querySelectorAll(\".scroll-stack-card\"));\r\n-    const n = cards.length;\r\n-    if (n === 0) return;\r\n-\r\n-    // set container min-height so there's enough scroll space to stack all cards\r\n-    // formula: viewportHeight * (n + 1) gives room for each card to pin then release\r\n+    const cards = cardsRef.current;\r\n+    const numCards = cards.length;\r\n     const vh = window.innerHeight;\r\n-    container.style.minHeight = `${vh * (n + 1)}px`;\r\n \r\n-    // set each card wrapper to sticky and give proper z-index so top card is last child\r\n-    cards.forEach((card, i) => {\r\n-      const idxFromBottom = i; // order as in DOM: first card is bottom-most\r\n-      card.style.position = \"sticky\";\r\n-      card.style.top = stackTop;\r\n-      card.style.zIndex = `${1000 - i}`; // later children visually in front if they come later in DOM\r\n-      card.dataset.stackIndex = i;\r\n-      // initial transform / scale\r\n-      card.style.transform = `translateY(${idxFromBottom * spacing}px) scale(${1 - idxFromBottom * scaleStep})`;\r\n-    });\r\n+    const containerHeight = vh * (numCards + 1);\r\n+    container.style.minHeight = `${containerHeight}px`;\r\n \r\n-    // scroll handler: compute progress through container and update translate for each card\r\n-    let rafId = null;\r\n-    const handle = () => {\r\n-      if (rafId) cancelAnimationFrame(rafId);\r\n-      rafId = requestAnimationFrame(() => {\r\n-        const rect = container.getBoundingClientRect();\r\n-        // distance scrolled into container (0 .. containerScrollableHeight)\r\n-        const containerTopToViewport = Math.max(0, -rect.top);\r\n-        const containerHeight = rect.height;\r\n-        const progress = Math.min(1, Math.max(0, containerTopToViewport / (containerHeight - vh)));\r\n+    const handleScroll = () => {\r\n+      const rect = container.getBoundingClientRect();\r\n+      const scrollY = -rect.top;\r\n \r\n-        // For each card, compute how far it should `rise` into the stack\r\n-        cards.forEach((card, i) => {\r\n-          // Each card becomes active a little later:\r\n-          const cardActivation = i / n; // 0 .. <1\r\n-          let localProgress = (progress - cardActivation) / (1 / n);\r\n-          localProgress = Math.min(1, Math.max(0, localProgress));\r\n+      cards.forEach((card, i) => {\r\n+        const progress = Math.min(\r\n+          Math.max(scrollY / (vh * (i + 1)), 0),\r\n+          1\r\n+        );\r\n+        const translateY = -progress * 50; // subtle upward push\r\n+        const scale = 1 - (numCards - i - 1) * 0.02 + progress * 0.02;\r\n \r\n-          // move card upward by spacing * (1 - localRemaining)\r\n-          // baseline translate = spacing * index (gives offset for stack)\r\n-          const baseOffset = i * spacing;\r\n-          // when localProgress reaches 1 -> card should be at top position (0 offset)\r\n-          const offset = Math.round((1 - localProgress) * baseOffset);\r\n-\r\n-          // scale effect\r\n-          const baseScale = 1 - i * scaleStep;\r\n-          const scale = baseScale + (1 - baseScale) * localProgress * 0.08; // tiny pop as active\r\n-\r\n-          // subtle elevation (box-shadow) while active\r\n-          const elev = Math.round(localProgress * 12);\r\n-\r\n-          card.style.transform = `translateY(${offset}px) scale(${scale})`;\r\n-          card.style.boxShadow = `0 ${4 + elev}px ${18 + elev}px rgba(12,16,24,${0.08 + localProgress * 0.06})`;\r\n-          card.style.opacity = `${0.7 + 0.3 * localProgress}`;\r\n-        });\r\n+        card.style.transform = `translateY(${translateY}px) scale(${scale})`;\r\n+        card.style.zIndex = `${100 + i}`;\r\n       });\r\n     };\r\n \r\n-    // initial paint\r\n-    handle();\r\n+    window.addEventListener(\"scroll\", handleScroll, { passive: true });\r\n+    handleScroll();\r\n+    return () => window.removeEventListener(\"scroll\", handleScroll);\r\n+  }, []);\r\n \r\n-    window.addEventListener(\"scroll\", handle, { passive: true });\r\n-    window.addEventListener(\"resize\", handle);\r\n-\r\n-    return () => {\r\n-      if (rafId) cancelAnimationFrame(rafId);\r\n-      window.removeEventListener(\"scroll\", handle);\r\n-      window.removeEventListener(\"resize\", handle);\r\n-      // cleanup inline styles we added\r\n-      container.style.minHeight = \"\";\r\n-      cards.forEach((card) => {\r\n-        card.style.position = \"\";\r\n-        card.style.top = \"\";\r\n-        card.style.zIndex = \"\";\r\n-        card.style.transform = \"\";\r\n-        card.style.boxShadow = \"\";\r\n-        card.style.opacity = \"\";\r\n-      });\r\n-    };\r\n-  }, [stackTop, spacing, scaleStep, children]);\r\n-\r\n-  // render children wrapped in wrapper that has .scroll-stack-card\r\n-  // If user already passed ScrollStackItem components with that class, we will keep them as-is.\r\n   return (\r\n-    <div className={`scroll-stack-container ${className}`} ref={containerRef}>\r\n-      <div className=\"scroll-stack-inner\">\r\n-        {React.Children.map(children, (child, i) => {\r\n-          // if the child already has class .scroll-stack-card, return as is (useful if using ScrollStackItem)\r\n-          if (child && child.props && String(child.props.className || \"\").includes(\"scroll-stack-card\")) {\r\n-            return child;\r\n-          }\r\n-          return (\r\n-            <div className=\"scroll-stack-card\">\r\n-              {child}\r\n-            </div>\r\n-          );\r\n-        })}\r\n+    <section className=\"scroll-stack\" ref={containerRef}>\r\n+      <div className=\"scroll-stack-sticky\">\r\n+        {React.Children.map(children, (child, i) => (\r\n+          <div\r\n+            className=\"scroll-stack-card\"\r\n+            ref={(el) => (cardsRef.current[i] = el)}\r\n+          >\r\n+            {child}\r\n+          </div>\r\n+        ))}\r\n       </div>\r\n-    </div>\r\n+    </section>\r\n   );\r\n };\r\n \r\n export default ScrollStack;\r\n"
                },
                {
                    "date": 1761551338751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,54 +1,59 @@\n import React, { useEffect, useRef } from \"react\";\r\n+import { gsap } from \"gsap\";\r\n+import { ScrollTrigger } from \"gsap/ScrollTrigger\";\r\n import \"./ScrollStack.css\";\r\n \r\n-const ScrollStack = ({ children, stackTop = \"10vh\" }) => {\r\n+gsap.registerPlugin(ScrollTrigger);\r\n+\r\n+const ScrollStack = ({ children }) => {\r\n   const containerRef = useRef(null);\r\n   const cardsRef = useRef([]);\r\n \r\n   useEffect(() => {\r\n     const container = containerRef.current;\r\n     const cards = cardsRef.current;\r\n     const numCards = cards.length;\r\n-    const vh = window.innerHeight;\r\n \r\n-    const containerHeight = vh * (numCards + 1);\r\n-    container.style.minHeight = `${containerHeight}px`;\r\n+    // Kill old triggers before re-init (in case of hot reload)\r\n+    ScrollTrigger.getAll().forEach((st) => st.kill());\r\n \r\n-    const handleScroll = () => {\r\n-      const rect = container.getBoundingClientRect();\r\n-      const scrollY = -rect.top;\r\n+    // Set initial states\r\n+    gsap.set(cards, { yPercent: 100, opacity: 0, scale: 0.95 });\r\n+    gsap.set(cards[0], { yPercent: 0, opacity: 1, scale: 1 });\r\n \r\n-      cards.forEach((card, i) => {\r\n-        const progress = Math.min(\r\n-          Math.max(scrollY / (vh * (i + 1)), 0),\r\n-          1\r\n-        );\r\n-        const translateY = -progress * 50; // subtle upward push\r\n-        const scale = 1 - (numCards - i - 1) * 0.02 + progress * 0.02;\r\n+    // Timeline controlled by scroll\r\n+    const tl = gsap.timeline({\r\n+      scrollTrigger: {\r\n+        trigger: container,\r\n+        start: \"top top\",\r\n+        end: `+=${numCards * 100}%`,\r\n+        pin: true,\r\n+        scrub: true,\r\n+        anticipatePin: 1,\r\n+      },\r\n+    });\r\n \r\n-        card.style.transform = `translateY(${translateY}px) scale(${scale})`;\r\n-        card.style.zIndex = `${100 + i}`;\r\n-      });\r\n-    };\r\n+    // Animate each card stacking above previous\r\n+    cards.forEach((card, i) => {\r\n+      if (i === 0) return;\r\n+      tl.to(cards[i - 1], { scale: 0.95, opacity: 0.8, duration: 0.5 }, i)\r\n+        .to(card, { yPercent: 0, opacity: 1, scale: 1, duration: 0.8 }, i);\r\n+    });\r\n \r\n-    window.addEventListener(\"scroll\", handleScroll, { passive: true });\r\n-    handleScroll();\r\n-    return () => window.removeEventListener(\"scroll\", handleScroll);\r\n+    return () => tl.scrollTrigger?.kill();\r\n   }, []);\r\n \r\n   return (\r\n     <section className=\"scroll-stack\" ref={containerRef}>\r\n-      <div className=\"scroll-stack-sticky\">\r\n-        {React.Children.map(children, (child, i) => (\r\n-          <div\r\n-            className=\"scroll-stack-card\"\r\n-            ref={(el) => (cardsRef.current[i] = el)}\r\n-          >\r\n-            {child}\r\n-          </div>\r\n-        ))}\r\n-      </div>\r\n+      {React.Children.map(children, (child, i) => (\r\n+        <div\r\n+          className=\"scroll-card\"\r\n+          ref={(el) => (cardsRef.current[i] = el)}\r\n+        >\r\n+          {child}\r\n+        </div>\r\n+      ))}\r\n     </section>\r\n   );\r\n };\r\n \r\n"
                },
                {
                    "date": 1761552142478,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,11 +38,11 @@\n \r\n     // Animate each card stacking above previous\r\n     cards.forEach((card, i) => {\r\n       if (i === 0) return; // Skip first card as it's already visible\r\n-      \r\n+\r\n       const position = i * 1; // Position in timeline\r\n-      \r\n+\r\n       // Fade out and scale down previous card\r\n       tl.to(\r\n         cards[i - 1],\r\n         {\r\n@@ -52,20 +52,20 @@\n           ease: \"power2.inOut\",\r\n         },\r\n         position\r\n       )\r\n-      // Bring in current card\r\n-      .to(\r\n-        card,\r\n-        {\r\n-          yPercent: 0,\r\n-          opacity: 1,\r\n-          scale: 1,\r\n-          duration: 0.8,\r\n-          ease: \"power2.out\",\r\n-        },\r\n-        position\r\n-      );\r\n+        // Bring in current card\r\n+        .to(\r\n+          card,\r\n+          {\r\n+            yPercent: 0,\r\n+            opacity: 1,\r\n+            scale: 1,\r\n+            duration: 0.8,\r\n+            ease: \"power2.out\",\r\n+          },\r\n+          position\r\n+        );\r\n     });\r\n \r\n     return () => {\r\n       tl.scrollTrigger?.kill();\r\n@@ -75,16 +75,13 @@\n \r\n   return (\r\n     <section className=\"scroll-stack\" ref={containerRef}>\r\n       {React.Children.map(children, (child, i) => (\r\n-        <div\r\n-          className=\"scroll-card\"\r\n-          ref={(el) => (cardsRef.current[i] = el)}\r\n-        >\r\n+        <div className=\"scroll-card\" ref={(el) => (cardsRef.current[i] = el)}>\r\n           {child}\r\n         </div>\r\n       ))}\r\n     </section>\r\n   );\r\n };\r\n \r\n\\ No newline at end of file\n-export default ScrollStack;\n+export default ScrollStack;\r\n"
                },
                {
                    "date": 1761552774650,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,89 @@\n+import React, { useEffect, useRef } from \"react\";\r\n+import { gsap } from \"gsap\";\r\n+import { ScrollTrigger } from \"gsap/ScrollTrigger\";\r\n+import \"./ScrollStack.css\";\r\n+\r\n+gsap.registerPlugin(ScrollTrigger);\r\n+\r\n+const ScrollStack = ({ children }) => {\r\n+  const containerRef = useRef(null);\r\n+  const cardsRef = useRef([]);\r\n+\r\n+  useEffect(() => {\r\n+    const container = containerRef.current;\r\n+    const cards = cardsRef.current;\r\n+    const numCards = cards.length;\r\n+\r\n+    if (!container || numCards === 0) return;\r\n+\r\n+    // Kill old triggers before re-init (in case of hot reload)\r\n+    ScrollTrigger.getAll().forEach((st) => st.kill());\r\n+\r\n+    // Set initial states - all cards start below except the first\r\n+    gsap.set(cards, { yPercent: 100, opacity: 0, scale: 0.95 });\r\n+    gsap.set(cards[0], { yPercent: 0, opacity: 1, scale: 1 });\r\n+\r\n+    // Timeline controlled by scroll - much longer to prevent overlap\r\n+    const tl = gsap.timeline({\r\n+      scrollTrigger: {\r\n+        trigger: container,\r\n+        start: \"top top\",\r\n+        end: `+=${numCards * 200}%`, // Significantly increased scroll distance\r\n+        pin: true,\r\n+        scrub: 1.5,\r\n+        anticipatePin: 1,\r\n+        invalidateOnRefresh: true,\r\n+      },\r\n+    });\r\n+\r\n+    // Animate each card stacking above previous with proper spacing\r\n+    cards.forEach((card, i) => {\r\n+      if (i === 0) return; // Skip first card as it's already visible\r\n+\r\n+      // Each card gets 2 units of timeline space - much more spacing\r\n+      const position = i * 2;\r\n+\r\n+      // Fade out and scale down previous card\r\n+      tl.to(\r\n+        cards[i - 1],\r\n+        {\r\n+          scale: 0.85,\r\n+          opacity: 0.4,\r\n+          y: -50, // Move up slightly\r\n+          duration: 0.8,\r\n+          ease: \"power2.inOut\",\r\n+        },\r\n+        position\r\n+      )\r\n+        // Bring in current card - starts after previous is well hidden\r\n+        .to(\r\n+          card,\r\n+          {\r\n+            yPercent: 0,\r\n+            opacity: 1,\r\n+            scale: 1,\r\n+            duration: 1.2,\r\n+            ease: \"power2.out\",\r\n+          },\r\n+          position + 0.4 // More delay to ensure smooth transition\r\n+        );\r\n+    });\r\n+\r\n+    return () => {\r\n+      tl.scrollTrigger?.kill();\r\n+      tl.kill();\r\n+    };\r\n+  }, []);\r\n+\r\n+  return (\r\n+    <section className=\"scroll-stack\" ref={containerRef}>\r\n+      {React.Children.map(children, (child, i) => (\r\n+        <div className=\"scroll-card\" ref={(el) => (cardsRef.current[i] = el)}>\r\n+          {child}\r\n+        </div>\r\n+      ))}\r\n+    </section>\r\n+  );\r\n+};\r\n+\r\n+export default ScrollStack;\r\n"
                }
            ],
            "date": 1761549143257,
            "name": "Commit-0",
            "content": "import { useLayoutEffect, useRef, useCallback } from 'react';\r\nimport Lenis from 'lenis';\r\nimport './ScrollStack.css';\r\n\r\nexport const ScrollStackItem = ({ children, itemClassName = '' }) => (\r\n  <div className={`scroll-stack-card ${itemClassName}`.trim()}>{children}</div>\r\n);\r\n\r\nconst ScrollStack = ({\r\n  children,\r\n  className = '',\r\n  itemDistance = 100,\r\n  itemScale = 0.03,\r\n  itemStackDistance = 30,\r\n  stackPosition = '20%',\r\n  scaleEndPosition = '10%',\r\n  baseScale = 0.85,\r\n  scaleDuration = 0.5,\r\n  rotationAmount = 0,\r\n  blurAmount = 0,\r\n  useWindowScroll = false,\r\n  onStackComplete\r\n}) => {\r\n  const scrollerRef = useRef(null);\r\n  const stackCompletedRef = useRef(false);\r\n  const animationFrameRef = useRef(null);\r\n  const lenisRef = useRef(null);\r\n  const cardsRef = useRef([]);\r\n  const lastTransformsRef = useRef(new Map());\r\n  const isUpdatingRef = useRef(false);\r\n\r\n  const calculateProgress = useCallback((scrollTop, start, end) => {\r\n    if (scrollTop < start) return 0;\r\n    if (scrollTop > end) return 1;\r\n    return (scrollTop - start) / (end - start);\r\n  }, []);\r\n\r\n  const parsePercentage = useCallback((value, containerHeight) => {\r\n    if (typeof value === 'string' && value.includes('%')) {\r\n      return (parseFloat(value) / 100) * containerHeight;\r\n    }\r\n    return parseFloat(value);\r\n  }, []);\r\n\r\n  const getScrollData = useCallback(() => {\r\n    if (useWindowScroll) {\r\n      return {\r\n        scrollTop: window.scrollY,\r\n        containerHeight: window.innerHeight,\r\n        scrollContainer: document.documentElement\r\n      };\r\n    } else {\r\n      const scroller = scrollerRef.current;\r\n      return {\r\n        scrollTop: scroller.scrollTop,\r\n        containerHeight: scroller.clientHeight,\r\n        scrollContainer: scroller\r\n      };\r\n    }\r\n  }, [useWindowScroll]);\r\n\r\n  const getElementOffset = useCallback(\r\n    element => {\r\n      if (useWindowScroll) {\r\n        const rect = element.getBoundingClientRect();\r\n        return rect.top + window.scrollY;\r\n      } else {\r\n        return element.offsetTop;\r\n      }\r\n    },\r\n    [useWindowScroll]\r\n  );\r\n\r\n  const updateCardTransforms = useCallback(() => {\r\n    if (!cardsRef.current.length || isUpdatingRef.current) return;\r\n\r\n    isUpdatingRef.current = true;\r\n\r\n    const { scrollTop, containerHeight, scrollContainer } = getScrollData();\r\n    const stackPositionPx = parsePercentage(stackPosition, containerHeight);\r\n    const scaleEndPositionPx = parsePercentage(scaleEndPosition, containerHeight);\r\n\r\n    const endElement = useWindowScroll\r\n      ? document.querySelector('.scroll-stack-end')\r\n      : scrollerRef.current?.querySelector('.scroll-stack-end');\r\n\r\n    const endElementTop = endElement ? getElementOffset(endElement) : 0;\r\n\r\n    cardsRef.current.forEach((card, i) => {\r\n      if (!card) return;\r\n\r\n      const cardTop = getElementOffset(card);\r\n      const triggerStart = cardTop - stackPositionPx - itemStackDistance * i;\r\n      const triggerEnd = cardTop - scaleEndPositionPx;\r\n      const pinStart = cardTop - stackPositionPx - itemStackDistance * i;\r\n      const pinEnd = endElementTop - containerHeight / 2;\r\n\r\n      const scaleProgress = calculateProgress(scrollTop, triggerStart, triggerEnd);\r\n      const targetScale = baseScale + i * itemScale;\r\n      const scale = 1 - scaleProgress * (1 - targetScale);\r\n      const rotation = rotationAmount ? i * rotationAmount * scaleProgress : 0;\r\n\r\n      let blur = 0;\r\n      if (blurAmount) {\r\n        let topCardIndex = 0;\r\n        for (let j = 0; j < cardsRef.current.length; j++) {\r\n          const jCardTop = getElementOffset(cardsRef.current[j]);\r\n          const jTriggerStart = jCardTop - stackPositionPx - itemStackDistance * j;\r\n          if (scrollTop >= jTriggerStart) {\r\n            topCardIndex = j;\r\n          }\r\n        }\r\n\r\n        if (i < topCardIndex) {\r\n          const depthInStack = topCardIndex - i;\r\n          blur = Math.max(0, depthInStack * blurAmount);\r\n        }\r\n      }\r\n\r\n      let translateY = 0;\r\n      const isPinned = scrollTop >= pinStart && scrollTop <= pinEnd;\r\n\r\n      if (isPinned) {\r\n        translateY = scrollTop - cardTop + stackPositionPx + itemStackDistance * i;\r\n      } else if (scrollTop > pinEnd) {\r\n        translateY = pinEnd - cardTop + stackPositionPx + itemStackDistance * i;\r\n      }\r\n\r\n      const newTransform = {\r\n        translateY: Math.round(translateY * 100) / 100,\r\n        scale: Math.round(scale * 1000) / 1000,\r\n        rotation: Math.round(rotation * 100) / 100,\r\n        blur: Math.round(blur * 100) / 100\r\n      };\r\n\r\n      const lastTransform = lastTransformsRef.current.get(i);\r\n      const hasChanged =\r\n        !lastTransform ||\r\n        Math.abs(lastTransform.translateY - newTransform.translateY) > 0.1 ||\r\n        Math.abs(lastTransform.scale - newTransform.scale) > 0.001 ||\r\n        Math.abs(lastTransform.rotation - newTransform.rotation) > 0.1 ||\r\n        Math.abs(lastTransform.blur - newTransform.blur) > 0.1;\r\n\r\n      if (hasChanged) {\r\n        const transform = `translate3d(0, ${newTransform.translateY}px, 0) scale(${newTransform.scale}) rotate(${newTransform.rotation}deg)`;\r\n        const filter = newTransform.blur > 0 ? `blur(${newTransform.blur}px)` : '';\r\n\r\n        card.style.transform = transform;\r\n        card.style.filter = filter;\r\n\r\n        lastTransformsRef.current.set(i, newTransform);\r\n      }\r\n\r\n      if (i === cardsRef.current.length - 1) {\r\n        const isInView = scrollTop >= pinStart && scrollTop <= pinEnd;\r\n        if (isInView && !stackCompletedRef.current) {\r\n          stackCompletedRef.current = true;\r\n          onStackComplete?.();\r\n        } else if (!isInView && stackCompletedRef.current) {\r\n          stackCompletedRef.current = false;\r\n        }\r\n      }\r\n    });\r\n\r\n    isUpdatingRef.current = false;\r\n  }, [\r\n    itemScale,\r\n    itemStackDistance,\r\n    stackPosition,\r\n    scaleEndPosition,\r\n    baseScale,\r\n    rotationAmount,\r\n    blurAmount,\r\n    useWindowScroll,\r\n    onStackComplete,\r\n    calculateProgress,\r\n    parsePercentage,\r\n    getScrollData,\r\n    getElementOffset\r\n  ]);\r\n\r\n  const handleScroll = useCallback(() => {\r\n    updateCardTransforms();\r\n  }, [updateCardTransforms]);\r\n\r\n  const setupLenis = useCallback(() => {\r\n    if (useWindowScroll) {\r\n      const lenis = new Lenis({\r\n        duration: 1.2,\r\n        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\r\n        smoothWheel: true,\r\n        touchMultiplier: 2,\r\n        infinite: false,\r\n        wheelMultiplier: 1,\r\n        lerp: 0.1,\r\n        syncTouch: true,\r\n        syncTouchLerp: 0.075\r\n      });\r\n\r\n      lenis.on('scroll', handleScroll);\r\n\r\n      const raf = time => {\r\n        lenis.raf(time);\r\n        animationFrameRef.current = requestAnimationFrame(raf);\r\n      };\r\n      animationFrameRef.current = requestAnimationFrame(raf);\r\n\r\n      lenisRef.current = lenis;\r\n      return lenis;\r\n    } else {\r\n      const scroller = scrollerRef.current;\r\n      if (!scroller) return;\r\n\r\n      const lenis = new Lenis({\r\n        wrapper: scroller,\r\n        content: scroller.querySelector('.scroll-stack-inner'),\r\n        duration: 1.2,\r\n        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\r\n        smoothWheel: true,\r\n        touchMultiplier: 2,\r\n        infinite: false,\r\n        gestureOrientationHandler: true,\r\n        normalizeWheel: true,\r\n        wheelMultiplier: 1,\r\n        touchInertiaMultiplier: 35,\r\n        lerp: 0.1,\r\n        syncTouch: true,\r\n        syncTouchLerp: 0.075,\r\n        touchInertia: 0.6\r\n      });\r\n\r\n      lenis.on('scroll', handleScroll);\r\n\r\n      const raf = time => {\r\n        lenis.raf(time);\r\n        animationFrameRef.current = requestAnimationFrame(raf);\r\n      };\r\n      animationFrameRef.current = requestAnimationFrame(raf);\r\n\r\n      lenisRef.current = lenis;\r\n      return lenis;\r\n    }\r\n  }, [handleScroll, useWindowScroll]);\r\n\r\n  useLayoutEffect(() => {\r\n    const scroller = scrollerRef.current;\r\n    if (!scroller) return;\r\n\r\n    const cards = Array.from(\r\n      useWindowScroll\r\n        ? document.querySelectorAll('.scroll-stack-card')\r\n        : scroller.querySelectorAll('.scroll-stack-card')\r\n    );\r\n\r\n    cardsRef.current = cards;\r\n    const transformsCache = lastTransformsRef.current;\r\n\r\n    cards.forEach((card, i) => {\r\n      if (i < cards.length - 1) {\r\n        card.style.marginBottom = `${itemDistance}px`;\r\n      }\r\n      card.style.willChange = 'transform, filter';\r\n      card.style.transformOrigin = 'top center';\r\n      card.style.backfaceVisibility = 'hidden';\r\n      card.style.transform = 'translateZ(0)';\r\n      card.style.webkitTransform = 'translateZ(0)';\r\n      card.style.perspective = '1000px';\r\n      card.style.webkitPerspective = '1000px';\r\n    });\r\n\r\n    setupLenis();\r\n\r\n    updateCardTransforms();\r\n\r\n    return () => {\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n      if (lenisRef.current) {\r\n        lenisRef.current.destroy();\r\n      }\r\n      stackCompletedRef.current = false;\r\n      cardsRef.current = [];\r\n      transformsCache.clear();\r\n      isUpdatingRef.current = false;\r\n    };\r\n  }, [\r\n    itemDistance,\r\n    itemScale,\r\n    itemStackDistance,\r\n    stackPosition,\r\n    scaleEndPosition,\r\n    baseScale,\r\n    scaleDuration,\r\n    rotationAmount,\r\n    blurAmount,\r\n    useWindowScroll,\r\n    onStackComplete,\r\n    setupLenis,\r\n    updateCardTransforms\r\n  ]);\r\n\r\n  return (\r\n    <div className={`scroll-stack-scroller ${className}`.trim()} ref={scrollerRef}>\r\n      <div className=\"scroll-stack-inner\">\r\n        {children}\r\n        {/* Spacer so the last pin can release cleanly */}\r\n        <div className=\"scroll-stack-end\" />\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ScrollStack;\r\n"
        }
    ]
}